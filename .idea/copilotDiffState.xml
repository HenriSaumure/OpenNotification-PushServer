<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PushServer&quot;&gt;&#10;&#10;        &lt;!-- Main Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.PushServer&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- Notification Listener Service --&gt;&#10;        &lt;service&#10;            android:name=&quot;.NotificationListenerService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:permission=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.service.notification.NotificationListenerService&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;!-- Boot receiver to restart service --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.BootReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter android:priority=&quot;1000&quot;&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;data android:scheme=&quot;package&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PushServer&quot;&gt;&#10;&#10;        &lt;!-- Main Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.PushServer&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- Notification Listener Service --&gt;&#10;        &lt;service&#10;            android:name=&quot;.NotificationListenerService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:foregroundServiceType=&quot;dataSync&quot;&#10;            android:permission=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.service.notification.NotificationListenerService&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;!-- Boot receiver to restart service --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.BootReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter android:priority=&quot;1000&quot;&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;data android:scheme=&quot;package&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/pushserver/BootReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/pushserver/BootReceiver.kt" />
              <option name="updatedContent" value="package org.opennotification.pushserver&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;&#10;class BootReceiver : BroadcastReceiver() {&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;BootReceiver&quot;&#10;    }&#10;    &#10;    override fun onReceive(context: Context, intent: Intent) {&#10;        Log.d(TAG, &quot;BootReceiver triggered: ${intent.action}&quot;)&#10;        &#10;        when (intent.action) {&#10;            Intent.ACTION_BOOT_COMPLETED,&#10;            Intent.ACTION_MY_PACKAGE_REPLACED,&#10;            Intent.ACTION_PACKAGE_REPLACED -&gt; {&#10;                Log.d(TAG, &quot;Starting notification service after boot/update&quot;)&#10;                &#10;                // Check if notification access is still enabled&#10;                if (isNotificationServiceEnabled(context)) {&#10;                    val serviceIntent = Intent(context, NotificationListenerService::class.java)&#10;                    context.startForegroundService(serviceIntent)&#10;                    LogManager.addLog(&quot;Service auto-started after boot&quot;)&#10;                } else {&#10;                    LogManager.addLog(&quot;Cannot start service - notification access not enabled&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun isNotificationServiceEnabled(context: Context): Boolean {&#10;        val packageName = context.packageName&#10;        val flat = android.provider.Settings.Secure.getString(&#10;            context.contentResolver, &#10;            &quot;enabled_notification_listeners&quot;&#10;        )&#10;        &#10;        if (flat != null) {&#10;            val names = flat.split(&quot;:&quot;).toTypedArray()&#10;            for (name in names) {&#10;                val componentName = android.content.ComponentName.unflattenFromString(name)&#10;                if (componentName != null) {&#10;                    if (packageName == componentName.packageName) {&#10;                        return true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/pushserver/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/pushserver/MainActivity.kt" />
              <option name="originalContent" value="package org.opennotification.pushserver&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.SharedPreferences&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.text.method.ScrollingMovementMethod&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.edit&#10;import androidx.core.view.WindowCompat&#10;import org.opennotification.pushserver.databinding.ActivityMainBinding&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    private lateinit var binding: ActivityMainBinding&#10;    private lateinit var prefs: SharedPreferences&#10;&#10;    companion object {&#10;        const val PREFS_NAME = &quot;OpenNotificationPrefs&quot;&#10;        const val PREF_SERVER_URL = &quot;server_url&quot;&#10;        const val PREF_GUID = &quot;guid&quot;&#10;        const val PREF_IGNORE_SYSTEM = &quot;ignore_system&quot;&#10;        const val DEFAULT_SERVER_URL = &quot;https://api.opennotification.org&quot;&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Enable edge-to-edge display&#10;        WindowCompat.setDecorFitsSystemWindows(window, false)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        prefs = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)&#10;&#10;        setupUI()&#10;        loadSettings()&#10;        updateStatus()&#10;    }&#10;&#10;    private fun setupUI() {&#10;        binding.textViewLog.movementMethod = ScrollingMovementMethod()&#10;&#10;        binding.buttonSaveSettings.setOnClickListener {&#10;            saveSettings()&#10;        }&#10;&#10;        binding.buttonEnableNotifications.setOnClickListener {&#10;            openNotificationSettings()&#10;        }&#10;    }&#10;&#10;    private fun loadSettings() {&#10;        val serverUrl = prefs.getString(PREF_SERVER_URL, DEFAULT_SERVER_URL)&#10;        val guid = prefs.getString(PREF_GUID, &quot;&quot;)&#10;        val ignoreSystem = prefs.getBoolean(PREF_IGNORE_SYSTEM, true)&#10;&#10;        binding.editTextServerUrl.setText(serverUrl)&#10;        binding.editTextGuid.setText(guid)&#10;        binding.switchIgnoreSystem.isChecked = ignoreSystem&#10;    }&#10;&#10;    private fun saveSettings() {&#10;        val serverUrl = binding.editTextServerUrl.text.toString().trim()&#10;        val guid = binding.editTextGuid.text.toString().trim()&#10;        val ignoreSystem = binding.switchIgnoreSystem.isChecked&#10;&#10;        if (serverUrl.isEmpty()) {&#10;            Toast.makeText(this, &quot;Server URL cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        if (guid.isEmpty()) {&#10;            Toast.makeText(this, &quot;GUID cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        prefs.edit {&#10;            putString(PREF_SERVER_URL, serverUrl)&#10;            putString(PREF_GUID, guid)&#10;            putBoolean(PREF_IGNORE_SYSTEM, ignoreSystem)&#10;        }&#10;&#10;        Toast.makeText(this, &quot;Settings saved&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;        // Restart the notification service to pick up new settings&#10;        if (isNotificationServiceEnabled()) {&#10;            val intent = Intent(this, NotificationListenerService::class.java).apply {&#10;                action = &quot;RESTART_SERVICE&quot;&#10;            }&#10;            startService(intent)&#10;        }&#10;    }&#10;&#10;    private fun openNotificationSettings() {&#10;        val intent = Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS)&#10;        startActivity(intent)&#10;    }&#10;&#10;    private fun isNotificationServiceEnabled(): Boolean {&#10;        val packageName = packageName&#10;        val flat = Settings.Secure.getString(contentResolver, &quot;enabled_notification_listeners&quot;)&#10;&#10;        if (flat != null) {&#10;            val names = flat.split(&quot;:&quot;).toTypedArray()&#10;            for (name in names) {&#10;                val componentName = ComponentName.unflattenFromString(name)&#10;                if (componentName != null) {&#10;                    if (packageName == componentName.packageName) {&#10;                        return true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    private fun updateStatus() {&#10;        val isEnabled = isNotificationServiceEnabled()&#10;        val hasSettings = prefs.getString(PREF_GUID, &quot;&quot;)?.isNotEmpty() == true&#10;&#10;        val status = when {&#10;            !isEnabled -&gt; &quot;Status: Notification access not enabled&quot;&#10;            !hasSettings -&gt; &quot;Status: Settings not configured&quot;&#10;            else -&gt; &quot;Status: Ready to forward notifications&quot;&#10;        }&#10;&#10;        binding.textViewStatus.text = status&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        updateStatus()&#10;        updateLogFromService()&#10;    }&#10;&#10;    private fun updateLogFromService() {&#10;        val logContent = LogManager.getLogContent()&#10;        if (logContent.isNotEmpty()) {&#10;            binding.textViewLog.text = logContent&#10;            // Scroll to bottom&#10;            binding.textViewLog.post {&#10;                val scrollView = binding.textViewLog.parent as? android.widget.ScrollView&#10;                scrollView?.fullScroll(android.view.View.FOCUS_DOWN)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.opennotification.pushserver&#10;&#10;import android.Manifest&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.SharedPreferences&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import android.text.method.ScrollingMovementMethod&#10;import android.widget.Toast&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.content.edit&#10;import androidx.core.view.WindowCompat&#10;import org.opennotification.pushserver.databinding.ActivityMainBinding&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    private lateinit var binding: ActivityMainBinding&#10;    private lateinit var prefs: SharedPreferences&#10;&#10;    companion object {&#10;        const val PREFS_NAME = &quot;OpenNotificationPrefs&quot;&#10;        const val PREF_SERVER_URL = &quot;server_url&quot;&#10;        const val PREF_GUID = &quot;guid&quot;&#10;        const val PREF_IGNORE_SYSTEM = &quot;ignore_system&quot;&#10;        const val DEFAULT_SERVER_URL = &quot;https://api.opennotification.org&quot;&#10;    }&#10;&#10;    // Permission launcher for notification permission&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            Toast.makeText(this, &quot;Notification permission granted&quot;, Toast.LENGTH_SHORT).show()&#10;            startForegroundServiceIfReady()&#10;        } else {&#10;            Toast.makeText(this, &quot;Notification permission denied - app may not work properly&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Enable edge-to-edge display&#10;        WindowCompat.setDecorFitsSystemWindows(window, false)&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        prefs = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)&#10;&#10;        setupUI()&#10;        loadSettings()&#10;        requestNotificationPermissionIfNeeded()&#10;        updateStatus()&#10;    }&#10;&#10;    private fun requestNotificationPermissionIfNeeded() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS)&#10;                != PackageManager.PERMISSION_GRANTED) {&#10;                notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;            } else {&#10;                startForegroundServiceIfReady()&#10;            }&#10;        } else {&#10;            startForegroundServiceIfReady()&#10;        }&#10;    }&#10;&#10;    private fun startForegroundServiceIfReady() {&#10;        if (isNotificationServiceEnabled()) {&#10;            val serviceIntent = Intent(this, NotificationListenerService::class.java)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                startForegroundService(serviceIntent)&#10;            } else {&#10;                startService(serviceIntent)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupUI() {&#10;        binding.textViewLog.movementMethod = ScrollingMovementMethod()&#10;&#10;        binding.buttonSaveSettings.setOnClickListener {&#10;            saveSettings()&#10;        }&#10;&#10;        binding.buttonEnableNotifications.setOnClickListener {&#10;            openNotificationSettings()&#10;        }&#10;    }&#10;&#10;    private fun loadSettings() {&#10;        val serverUrl = prefs.getString(PREF_SERVER_URL, DEFAULT_SERVER_URL)&#10;        val guid = prefs.getString(PREF_GUID, &quot;&quot;)&#10;        val ignoreSystem = prefs.getBoolean(PREF_IGNORE_SYSTEM, true)&#10;&#10;        binding.editTextServerUrl.setText(serverUrl)&#10;        binding.editTextGuid.setText(guid)&#10;        binding.switchIgnoreSystem.isChecked = ignoreSystem&#10;    }&#10;&#10;    private fun saveSettings() {&#10;        val serverUrl = binding.editTextServerUrl.text.toString().trim()&#10;        val guid = binding.editTextGuid.text.toString().trim()&#10;        val ignoreSystem = binding.switchIgnoreSystem.isChecked&#10;&#10;        if (serverUrl.isEmpty()) {&#10;            Toast.makeText(this, &quot;Server URL cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        if (guid.isEmpty()) {&#10;            Toast.makeText(this, &quot;GUID cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        prefs.edit {&#10;            putString(PREF_SERVER_URL, serverUrl)&#10;            putString(PREF_GUID, guid)&#10;            putBoolean(PREF_IGNORE_SYSTEM, ignoreSystem)&#10;        }&#10;&#10;        Toast.makeText(this, &quot;Settings saved&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;        // Restart the notification service to pick up new settings&#10;        if (isNotificationServiceEnabled()) {&#10;            val intent = Intent(this, NotificationListenerService::class.java).apply {&#10;                action = &quot;RESTART_SERVICE&quot;&#10;            }&#10;            startService(intent)&#10;        }&#10;    }&#10;&#10;    private fun openNotificationSettings() {&#10;        val intent = Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS)&#10;        startActivity(intent)&#10;    }&#10;&#10;    private fun isNotificationServiceEnabled(): Boolean {&#10;        val packageName = packageName&#10;        val flat = Settings.Secure.getString(contentResolver, &quot;enabled_notification_listeners&quot;)&#10;&#10;        if (flat != null) {&#10;            val names = flat.split(&quot;:&quot;).toTypedArray()&#10;            for (name in names) {&#10;                val componentName = ComponentName.unflattenFromString(name)&#10;                if (componentName != null) {&#10;                    if (packageName == componentName.packageName) {&#10;                        return true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    private fun updateStatus() {&#10;        val isEnabled = isNotificationServiceEnabled()&#10;        val hasSettings = prefs.getString(PREF_GUID, &quot;&quot;)?.isNotEmpty() == true&#10;&#10;        val status = when {&#10;            !isEnabled -&gt; &quot;Status: Notification access not enabled&quot;&#10;            !hasSettings -&gt; &quot;Status: Settings not configured&quot;&#10;            else -&gt; &quot;Status: Ready to forward notifications&quot;&#10;        }&#10;&#10;        binding.textViewStatus.text = status&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        updateStatus()&#10;        updateLogFromService()&#10;    }&#10;&#10;    private fun updateLogFromService() {&#10;        val logContent = LogManager.getLogContent()&#10;        if (logContent.isNotEmpty()) {&#10;            binding.textViewLog.text = logContent&#10;            // Scroll to bottom&#10;            binding.textViewLog.post {&#10;                val scrollView = binding.textViewLog.parent as? android.widget.ScrollView&#10;                scrollView?.fullScroll(android.view.View.FOCUS_DOWN)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/org/opennotification/pushserver/NotificationListenerService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/org/opennotification/pushserver/NotificationListenerService.kt" />
              <option name="originalContent" value="package org.opennotification.pushserver&#10;&#10;import android.app.Notification&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.SharedPreferences&#10;import android.service.notification.NotificationListenerService&#10;import android.service.notification.StatusBarNotification&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import okhttp3.Call&#10;import okhttp3.Callback&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import okhttp3.Response&#10;import org.json.JSONObject&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class NotificationListenerService : NotificationListenerService() {&#10;&#10;    private lateinit var prefs: SharedPreferences&#10;    private val httpClient = OkHttpClient.Builder()&#10;        .connectTimeout(10, TimeUnit.SECONDS)&#10;        .writeTimeout(10, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    companion object {&#10;        private const val TAG = &quot;NotificationListener&quot;&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        prefs = getSharedPreferences(MainActivity.PREFS_NAME, MODE_PRIVATE)&#10;        LogManager.addLog(&quot;Service started&quot;)&#10;        Log.d(TAG, &quot;NotificationListenerService created&quot;)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        if (intent?.action == &quot;RESTART_SERVICE&quot;) {&#10;            LogManager.addLog(&quot;Service restarted with new settings&quot;)&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    override fun onNotificationPosted(sbn: StatusBarNotification) {&#10;        super.onNotificationPosted(sbn)&#10;&#10;        // Skip our own notifications to avoid loops&#10;        if (sbn.packageName == packageName) {&#10;            return&#10;        }&#10;&#10;        // Check if we should ignore system notifications&#10;        val ignoreSystem = prefs.getBoolean(MainActivity.PREF_IGNORE_SYSTEM, true)&#10;        if (ignoreSystem &amp;&amp; isSystemNotification(sbn.packageName)) {&#10;            LogManager.addLog(&quot;Ignored system notification from ${sbn.packageName}&quot;)&#10;            return&#10;        }&#10;&#10;        val notification = sbn.notification&#10;        if (notification == null) {&#10;            return&#10;        }&#10;&#10;        // Extract notification details&#10;        val title = getNotificationTitle(notification)&#10;        val text = getNotificationText(notification)&#10;        val packageName = sbn.packageName&#10;&#10;        if (title.isNullOrBlank() &amp;&amp; text.isNullOrBlank()) {&#10;            return // Skip empty notifications&#10;        }&#10;&#10;        LogManager.addLog(&quot;New notification from $packageName: $title&quot;)&#10;&#10;        // Send to API&#10;        sendNotificationToAPI(title, text, packageName, sbn)&#10;    }&#10;&#10;    private fun getNotificationTitle(notification: Notification): String? {&#10;        return notification.extras?.getCharSequence(Notification.EXTRA_TITLE)?.toString()&#10;    }&#10;&#10;    private fun getNotificationText(notification: Notification): String? {&#10;        return notification.extras?.getCharSequence(Notification.EXTRA_TEXT)?.toString()&#10;            ?: notification.extras?.getCharSequence(Notification.EXTRA_BIG_TEXT)?.toString()&#10;    }&#10;&#10;    private fun sendNotificationToAPI(&#10;        title: String?,&#10;        description: String?,&#10;        packageName: String,&#10;        sbn: StatusBarNotification&#10;    ) {&#10;        val serverUrl = prefs.getString(MainActivity.PREF_SERVER_URL, MainActivity.DEFAULT_SERVER_URL)&#10;        val guid = prefs.getString(MainActivity.PREF_GUID, &quot;&quot;)&#10;&#10;        if (serverUrl.isNullOrBlank() || guid.isNullOrBlank()) {&#10;            LogManager.addLog(&quot;Error: Server URL or GUID not configured&quot;)&#10;            return&#10;        }&#10;&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val json = JSONObject().apply {&#10;                    put(&quot;guid&quot;, guid)&#10;                    put(&quot;title&quot;, title ?: &quot;Notification&quot;)&#10;                    put(&quot;description&quot;, description ?: &quot;&quot;)&#10;                    put(&quot;icon&quot;, packageName) // Use package name as icon identifier&#10;                    put(&quot;isAlert&quot;, false)&#10;                }&#10;&#10;                val requestBody = json.toString().toRequestBody(&quot;application/json&quot;.toMediaType())&#10;                val request = Request.Builder()&#10;                    .url(&quot;$serverUrl/notification&quot;)&#10;                    .post(requestBody)&#10;                    .build()&#10;&#10;                httpClient.newCall(request).enqueue(object : Callback {&#10;                    override fun onFailure(call: Call, e: IOException) {&#10;                        LogManager.addLog(&quot;Failed to send notification: ${e.message}&quot;)&#10;                        Log.e(TAG, &quot;API call failed&quot;, e)&#10;                    }&#10;&#10;                    override fun onResponse(call: Call, response: Response) {&#10;                        if (response.isSuccessful) {&#10;                            LogManager.addLog(&quot;✓ Sent: ${title ?: &quot;Notification&quot;}&quot;)&#10;                        } else {&#10;                            LogManager.addLog(&quot;API error ${response.code}: ${response.message}&quot;)&#10;                        }&#10;                        response.close()&#10;                    }&#10;                })&#10;&#10;            } catch (e: Exception) {&#10;                LogManager.addLog(&quot;Exception sending notification: ${e.message}&quot;)&#10;                Log.e(TAG, &quot;Exception in sendNotificationToAPI&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isSystemNotification(packageName: String): Boolean {&#10;        val systemPackages = setOf(&#10;            // Android system&#10;            &quot;android&quot;,&#10;            &quot;com.android.systemui&quot;,&#10;            &quot;com.android.settings&quot;,&#10;            &quot;com.android.providers.settings&quot;,&#10;            &quot;com.android.phone&quot;,&#10;            &quot;com.android.dialer&quot;,&#10;            &quot;com.android.contacts&quot;,&#10;            &quot;com.android.calculator2&quot;,&#10;            &quot;com.android.calendar&quot;,&#10;            &quot;com.android.deskclock&quot;,&#10;            &quot;com.android.packageinstaller&quot;,&#10;            &quot;com.android.permissioncontroller&quot;,&#10;            &quot;com.android.cellbroadcastreceiver&quot;,&#10;            &quot;com.android.emergency&quot;,&#10;&#10;            // Google Play Services and Store&#10;            &quot;com.google.android.gms&quot;,&#10;            &quot;com.google.android.gsf&quot;,&#10;            &quot;com.android.vending&quot;,&#10;            &quot;com.google.android.packageinstaller&quot;,&#10;            &quot;com.google.android.permissioncontroller&quot;,&#10;&#10;            // Samsung system (common OEM)&#10;            &quot;com.samsung.android.dialer&quot;,&#10;            &quot;com.samsung.android.contacts&quot;,&#10;            &quot;com.samsung.android.app.settings&quot;,&#10;            &quot;com.sec.android.app.launcher&quot;,&#10;            &quot;com.samsung.android.messaging&quot;,&#10;&#10;            // Other common system packages&#10;            &quot;com.miui.securitycenter&quot;, // Xiaomi&#10;            &quot;com.huawei.systemmanager&quot;, // Huawei&#10;            &quot;com.oneplus.security&quot;, // OnePlus&#10;            &quot;com.coloros.safecenter&quot;, // Oppo/Realme&#10;            &quot;com.bbk.theme&quot;, // Vivo&#10;&#10;            // Security and device management&#10;            &quot;com.android.keychain&quot;,&#10;            &quot;com.android.certinstaller&quot;,&#10;            &quot;com.android.managedprovisioning&quot;&#10;        )&#10;&#10;        return systemPackages.contains(packageName) ||&#10;                packageName.startsWith(&quot;com.android.&quot;) ||&#10;                packageName.startsWith(&quot;com.google.android.&quot;) ||&#10;                packageName.startsWith(&quot;android.&quot;) ||&#10;                packageName.contains(&quot;system&quot;) ||&#10;                packageName.contains(&quot;settings&quot;)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        LogManager.addLog(&quot;Service stopped&quot;)&#10;        Log.d(TAG, &quot;NotificationListenerService destroyed&quot;)&#10;    }&#10;&#10;    override fun onListenerConnected() {&#10;        super.onListenerConnected()&#10;        LogManager.addLog(&quot;Notification listener connected&quot;)&#10;        Log.d(TAG, &quot;Notification listener connected&quot;)&#10;    }&#10;&#10;    override fun onListenerDisconnected() {&#10;        super.onListenerDisconnected()&#10;        LogManager.addLog(&quot;Notification listener disconnected&quot;)&#10;        Log.d(TAG, &quot;Notification listener disconnected&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.opennotification.pushserver&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.SharedPreferences&#10;import android.os.Build&#10;import android.service.notification.NotificationListenerService&#10;import android.service.notification.StatusBarNotification&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import okhttp3.Call&#10;import okhttp3.Callback&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import okhttp3.Response&#10;import org.json.JSONObject&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;&#10;class NotificationListenerService : NotificationListenerService() {&#10;&#10;    private lateinit var prefs: SharedPreferences&#10;    private val httpClient = OkHttpClient.Builder()&#10;        .connectTimeout(10, TimeUnit.SECONDS)&#10;        .writeTimeout(10, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    companion object {&#10;        private const val TAG = &quot;NotificationListener&quot;&#10;        private const val NOTIFICATION_ID = 1001&#10;        private const val CHANNEL_ID = &quot;opennotification_service&quot;&#10;        private const val CHANNEL_NAME = &quot;OpenNotification Service&quot;&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        prefs = getSharedPreferences(MainActivity.PREFS_NAME, MODE_PRIVATE)&#10;        createNotificationChannel()&#10;        startForegroundService()&#10;        LogManager.addLog(&quot;Service started as foreground service&quot;)&#10;        Log.d(TAG, &quot;NotificationListenerService created&quot;)&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                CHANNEL_NAME,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Keeps OpenNotification service running in background&quot;&#10;                setShowBadge(false)&#10;                enableLights(false)&#10;                enableVibration(false)&#10;                setSound(null, null)&#10;            }&#10;&#10;            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun startForegroundService() {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, notificationIntent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;OpenNotification Active&quot;)&#10;            .setContentText(&quot;Forwarding notifications to server&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setCategory(NotificationCompat.CATEGORY_SERVICE)&#10;            .setShowWhen(false)&#10;            .build()&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            startForeground(NOTIFICATION_ID, notification, android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC)&#10;        } else {&#10;            startForeground(NOTIFICATION_ID, notification)&#10;        }&#10;    }&#10;&#10;    private fun updateForegroundNotification(status: String) {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, notificationIntent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;OpenNotification Active&quot;)&#10;            .setContentText(status)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setCategory(NotificationCompat.CATEGORY_SERVICE)&#10;            .setShowWhen(false)&#10;            .build()&#10;&#10;        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        notificationManager.notify(NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        if (intent?.action == &quot;RESTART_SERVICE&quot;) {&#10;            LogManager.addLog(&quot;Service restarted with new settings&quot;)&#10;            updateForegroundNotification(&quot;Restarted - Forwarding notifications&quot;)&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    override fun onNotificationPosted(sbn: StatusBarNotification) {&#10;        super.onNotificationPosted(sbn)&#10;&#10;        // Skip our own notifications to avoid loops&#10;        if (sbn.packageName == packageName) {&#10;            return&#10;        }&#10;&#10;        // Check if we should ignore system notifications&#10;        val ignoreSystem = prefs.getBoolean(MainActivity.PREF_IGNORE_SYSTEM, true)&#10;        if (ignoreSystem &amp;&amp; isSystemNotification(sbn.packageName)) {&#10;            LogManager.addLog(&quot;Ignored system notification from ${sbn.packageName}&quot;)&#10;            return&#10;        }&#10;&#10;        val notification = sbn.notification&#10;        if (notification == null) {&#10;            return&#10;        }&#10;&#10;        // Extract notification details&#10;        val title = getNotificationTitle(notification)&#10;        val text = getNotificationText(notification)&#10;        val packageName = sbn.packageName&#10;&#10;        if (title.isNullOrBlank() &amp;&amp; text.isNullOrBlank()) {&#10;            return // Skip empty notifications&#10;        }&#10;&#10;        LogManager.addLog(&quot;New notification from $packageName: $title&quot;)&#10;        updateForegroundNotification(&quot;Last: $packageName&quot;)&#10;&#10;        // Send to API&#10;        sendNotificationToAPI(title, text, packageName, sbn)&#10;    }&#10;&#10;    private fun getNotificationTitle(notification: Notification): String? {&#10;        return notification.extras?.getCharSequence(Notification.EXTRA_TITLE)?.toString()&#10;    }&#10;&#10;    private fun getNotificationText(notification: Notification): String? {&#10;        return notification.extras?.getCharSequence(Notification.EXTRA_TEXT)?.toString()&#10;            ?: notification.extras?.getCharSequence(Notification.EXTRA_BIG_TEXT)?.toString()&#10;    }&#10;&#10;    private fun sendNotificationToAPI(&#10;        title: String?,&#10;        description: String?,&#10;        packageName: String,&#10;        sbn: StatusBarNotification&#10;    ) {&#10;        val serverUrl = prefs.getString(MainActivity.PREF_SERVER_URL, MainActivity.DEFAULT_SERVER_URL)&#10;        val guid = prefs.getString(MainActivity.PREF_GUID, &quot;&quot;)&#10;&#10;        if (serverUrl.isNullOrBlank() || guid.isNullOrBlank()) {&#10;            LogManager.addLog(&quot;Error: Server URL or GUID not configured&quot;)&#10;            return&#10;        }&#10;&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                // Get app name from package name&#10;                val appName = getAppNameFromPackage(packageName)&#10;&#10;                // Create formatted title with app name&#10;                val formattedTitle = if (title.isNullOrBlank()) {&#10;                    appName&#10;                } else {&#10;                    &quot;$appName - $title&quot;&#10;                }&#10;&#10;                // Generate action link to open the app&#10;                val actionLink = generateAppLaunchLink(packageName)&#10;&#10;                val json = JSONObject().apply {&#10;                    put(&quot;guid&quot;, guid)&#10;                    put(&quot;title&quot;, formattedTitle)&#10;                    put(&quot;description&quot;, description ?: &quot;&quot;)&#10;                    put(&quot;icon&quot;, packageName) // Use package name as icon identifier&#10;                    put(&quot;actionLink&quot;, actionLink)&#10;                    put(&quot;isAlert&quot;, false)&#10;                }&#10;&#10;                val requestBody = json.toString().toRequestBody(&quot;application/json&quot;.toMediaType())&#10;                val request = Request.Builder()&#10;                    .url(&quot;$serverUrl/notification&quot;)&#10;                    .post(requestBody)&#10;                    .build()&#10;&#10;                httpClient.newCall(request).enqueue(object : Callback {&#10;                    override fun onFailure(call: Call, e: IOException) {&#10;                        LogManager.addLog(&quot;Failed to send notification: ${e.message}&quot;)&#10;                        Log.e(TAG, &quot;API call failed&quot;, e)&#10;                    }&#10;&#10;                    override fun onResponse(call: Call, response: Response) {&#10;                        if (response.isSuccessful) {&#10;                            LogManager.addLog(&quot;✓ Sent: $formattedTitle&quot;)&#10;                        } else {&#10;                            LogManager.addLog(&quot;API error ${response.code}: ${response.message}&quot;)&#10;                        }&#10;                        response.close()&#10;                    }&#10;                })&#10;&#10;            } catch (e: Exception) {&#10;                LogManager.addLog(&quot;Exception sending notification: ${e.message}&quot;)&#10;                Log.e(TAG, &quot;Exception in sendNotificationToAPI&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getAppNameFromPackage(packageName: String): String {&#10;        return try {&#10;            val applicationInfo = packageManager.getApplicationInfo(packageName, 0)&#10;            packageManager.getApplicationLabel(applicationInfo).toString()&#10;        } catch (e: Exception) {&#10;            // Fallback to package name if app name can't be retrieved&#10;            packageName.split(&quot;.&quot;).lastOrNull()?.replaceFirstChar { it.uppercase() } ?: packageName&#10;        }&#10;    }&#10;&#10;    private fun generateAppLaunchLink(packageName: String): String {&#10;        return try {&#10;            val launchIntent = packageManager.getLaunchIntentForPackage(packageName)&#10;            if (launchIntent != null) {&#10;                // Create a custom scheme that can be used to launch the app&#10;                &quot;app://$packageName&quot;&#10;            } else {&#10;                // Fallback to Play Store link if app can't be launched directly&#10;                &quot;https://play.google.com/store/apps/details?id=$packageName&quot;&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback to Play Store link&#10;            &quot;https://play.google.com/store/apps/details?id=$packageName&quot;&#10;        }&#10;    }&#10;&#10;    private fun isSystemNotification(packageName: String): Boolean {&#10;        val systemPackages = setOf(&#10;            // Android system&#10;            &quot;android&quot;,&#10;            &quot;com.android.systemui&quot;,&#10;            &quot;com.android.settings&quot;,&#10;            &quot;com.android.providers.settings&quot;,&#10;            &quot;com.android.phone&quot;,&#10;            &quot;com.android.dialer&quot;,&#10;            &quot;com.android.contacts&quot;,&#10;            &quot;com.android.calculator2&quot;,&#10;            &quot;com.android.calendar&quot;,&#10;            &quot;com.android.deskclock&quot;,&#10;            &quot;com.android.packageinstaller&quot;,&#10;            &quot;com.android.permissioncontroller&quot;,&#10;            &quot;com.android.cellbroadcastreceiver&quot;,&#10;            &quot;com.android.emergency&quot;,&#10;&#10;            // Google Play Services and Store&#10;            &quot;com.google.android.gms&quot;,&#10;            &quot;com.google.android.gsf&quot;,&#10;            &quot;com.android.vending&quot;,&#10;            &quot;com.google.android.packageinstaller&quot;,&#10;            &quot;com.google.android.permissioncontroller&quot;,&#10;&#10;            // Samsung system (common OEM)&#10;            &quot;com.samsung.android.dialer&quot;,&#10;            &quot;com.samsung.android.contacts&quot;,&#10;            &quot;com.samsung.android.app.settings&quot;,&#10;            &quot;com.sec.android.app.launcher&quot;,&#10;            &quot;com.samsung.android.messaging&quot;,&#10;&#10;            // Other common system packages&#10;            &quot;com.miui.securitycenter&quot;, // Xiaomi&#10;            &quot;com.huawei.systemmanager&quot;, // Huawei&#10;            &quot;com.oneplus.security&quot;, // OnePlus&#10;            &quot;com.coloros.safecenter&quot;, // Oppo/Realme&#10;            &quot;com.bbk.theme&quot;, // Vivo&#10;&#10;            // Security and device management&#10;            &quot;com.android.keychain&quot;,&#10;            &quot;com.android.certinstaller&quot;,&#10;            &quot;com.android.managedprovisioning&quot;&#10;        )&#10;&#10;        return systemPackages.contains(packageName) ||&#10;                packageName.startsWith(&quot;com.android.&quot;) ||&#10;                packageName.startsWith(&quot;com.google.android.&quot;) ||&#10;                packageName.startsWith(&quot;android.&quot;) ||&#10;                packageName.contains(&quot;system&quot;) ||&#10;                packageName.contains(&quot;settings&quot;)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        LogManager.addLog(&quot;Service stopped&quot;)&#10;        Log.d(TAG, &quot;NotificationListenerService destroyed&quot;)&#10;    }&#10;&#10;    override fun onListenerConnected() {&#10;        super.onListenerConnected()&#10;        LogManager.addLog(&quot;Notification listener connected&quot;)&#10;        Log.d(TAG, &quot;Notification listener connected&quot;)&#10;    }&#10;&#10;    override fun onListenerDisconnected() {&#10;        super.onListenerDisconnected()&#10;        LogManager.addLog(&quot;Notification listener disconnected&quot;)&#10;        Log.d(TAG, &quot;Notification listener disconnected&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>